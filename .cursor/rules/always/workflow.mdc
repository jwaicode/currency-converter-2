---
description: 
globs: 
alwaysApply: false
---
rule_type: always
name: workflow
description: System-level behavior and collaboration workflow for Cursor agent.

Purpose: Defines Cursor's system-level behavior and overall approach to project work. Guides the thinking process, reflection cycle, and collaboration workflow.

Workflow Structure:

1. Understand the User Prompt
2. Load core context (`@project_context`, `@system_design`, memories).
3. Verify assumptions ‚Äî ask clarification if unclear.
4. Generate ideas using CoT (Chain-of-Thought).
5. Reflect using `@reflection` BEFORE proposing actions.
6. Share plan with user ‚Üí await approval.
7. After approval, ACT and edit code.
8. Before committing, auto-include `@selfcheck` (agentRequested rule) and run checklist.
9. Execute all Git operations (branch, commit, push, PR, merge, review) via the GitHub MCP tool suite (`mcp_GitHub_*`). Follow naming + commit-message conventions in `@git-automation`. Every feature/fix/chore/update must start by creating a dedicated branch following the pattern `type/short-slug`. Cursor **MUST NOT** perform destructive actions such as `push --force`, history rewrites, `reset --hard`, or branch deletions; use only additive, non-destructive operations.
10. If debugging is needed (tests fail, runtime error), auto-include `@debugging` to guide the process.
11. After successful **project** changes, append a concise entry to `workhistory.mdc` (agentRequested rule).
    ‚Ä¢ If the change is a **Cursor self-improvement** (edits to workflow/reflection/selfcheck/etc.), log it instead to `cursor_upgrade_history.mdc` in the agent rules folder.

Key Auto-Include Logic:
- **Pre-commit** ‚Üí `selfcheck` checklist.
- **Any Git operation** ‚Üí GitHub MCP tools (`mcp_GitHub_*`) are used automatically; `git-automation` provides commit/branch conventions.
- **When error/bug detected** ‚Üí `debugging` prompts.

### üîç Version & Compatibility Gate (universal rule)
Before proposing or applying any new package, SDK, framework, or runtime upgrade **in any project**:
1. Identify the project's current primary runtimes (language versions, frameworks, SDKs).
2. Cross-check candidate dependencies or version bumps against official compatibility tables or release notes.
3. If compatibility is uncertain, ASK the user for their exact versions or confirm via research.
4. Document the compatibility reasoning in the assistant response.

Failing this gate is considered a workflow breach and should trigger an explicit reflection step.






